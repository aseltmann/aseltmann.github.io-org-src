#+title: @lexseltmann
#+author: Alex Seltmann
#+hugo_base_dir: .
#+options: creator:t
#+hugo_auto_set_lastmod: t

#+hugo_pandoc_citations: t
#+bibliography: cite/references.bib
#+bibliography: cite/books.bib

* Homepage
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:EXPORT_HUGO_TYPE: "docs"
:EXPORT_FILE_NAME: _index.en.md
:EXPORT_HUGO_MENU: :menu "main"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :link-citations true
:END:

** Hi, I'm Alex

I am a researcher and physician, currently working with Marie von
Lilienfeld-Toal at the [[https://news.rub.de/leute/2023-07-07-medizin-willst-du-mich-behandeln-musst-du-wissen-wer-ich-bin][Institute for Diversity Medicine]] at Ruhr University
Bochum, formerly at the [[http://www.biophysical-imaging.com][Biophysical Imaging Lab]] of Christian Eggeling in Jena.

** Contact

You can get in contact with me by sending an email to =alexander.seltmann (at) rub
(dot) de=. You can also find me on [[https://github.com/aseltmann][Github]].

I prefer to be addressed with neutral or no pronouns (Dear Alex | Dear Alex
Seltmann).

* Homepage_de
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:EXPORT_FILE_NAME: _index.de.md
:END:

** Hallo, ich bin Alex

Ich bin Forschende:r und Mediziner:in, aktuell tätig bei Marie von
Lilienfeld-Toal am [[https://news.rub.de/leute/2023-07-07-medizin-willst-du-mich-behandeln-musst-du-wissen-wer-ich-bin][Institut für Diversitätsmedizin]] der Ruhr-Universität Bochum,
davor in der [[http://www.biophysical-imaging.com][Biophysical Imaging Gruppe]] von Christian Eggeling in Jena.

** Kontakt
Ich bin per Email erreichbar unter =alexander.seltmann (at) rub
(dot) de=. Weiterhin bin ich zu finden auf [[https://github.com/aseltmann][Github]].

* Projects
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/projects
:END:

** Projects
:PROPERTIES:
:EXPORT_FILE_NAME: _index.en.md
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection false
:END:

*** Current projects
    I am a believer in the principles of Open Science, Open Data and Open
    Source. Thus, I am currently working on a reproducible way of conducting my
    research on simulation of Fluorescence Correlation Spectroscopy (FCS)
    measurements and correcting artifacts using neural networks, such as
    Convolutional Neural Nets (CNNs). I do not have my workflow fixed yet, but
    to have an insight in my current approach - and with the principles of
    [[https://en.wikipedia.org/wiki/Open-notebook_science][Open-notebook science]] in mind:

    #+BEGIN_EXPORT html
    <a href="https://aseltmann.github.io/fluotracify/">Fluotracify - doctoral research project done in a reproducible way</a>
    #+END_EXPORT

    Description: In a current project, we apply Deep Learning techniques on Fluorescence
    Correlation Spectroscopy (FCS) data to correct a variety of hardware- and
    sample-related artifacts, such as photobleaching, contamination from additional
    slow moving particles, or sudden drops in intensity because of detector
    anomalies.

*** Conference talks
- *Seltmann A*, Eggeling C, Waithe D. Automated, User-independent Correction of
  Artifacts in Fluorescence Correlation Spectroscopy Measurements using
  Convolutional Neural Networks. [[https://www.quantitativebioimaging.com/qbi2020/][Quantitative BioImaging Conference (QBI)]]; 2020
  Jan 6-9; Oxford, UK

* Projekte
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/projects
:END:
** Projekte
:PROPERTIES:
:EXPORT_FILE_NAME: _index.de.md
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection false
:END:

*** Aktuelle Projekte
    Ich glaube an die Prinzipien von Open Science, Open Data und Open Source.
    Daher arbeite ich aktuell daran, meine Forschung an
    Fluoreszenzkorrelationsspektroskopie (FCS) und Maschinellem Lernen in einer
    offenen Art und Weise verfügbar zu machen. Im Sinne der [[https://en.wikipedia.org/wiki/Open-notebook_science][Open-notebook
    science]] ist hier ein Einblick in meine aktuelle Forschung zu finden:

    #+BEGIN_EXPORT html
    <a href="https://aseltmann.github.io/fluotracify/">Fluotracify - eine reproduzierbare Doktorarbeit [Englisch]</a>
    #+END_EXPORT

*** Präsentationen auf Konferenzen
- *Seltmann A*, Eggeling C, Waithe D. Automated, User-independent Correction of
  Artifacts in Fluorescence Correlation Spectroscopy Measurements using
  Convolutional Neural Networks. [[https://www.quantitativebioimaging.com/qbi2020/][Quantitative BioImaging Conference (QBI)]]; 2020
  Jan 6-9; Oxford, UK

* Notes
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes
:END:

** Notes
:PROPERTIES:
:EXPORT_FILE_NAME: _index.en.md
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection false
:END:

** TODO Test page
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: docs/notes/test
  :EXPORT_FILE_NAME: test-page
  :END:
*** Year numbering system
#+BEGIN_EXPORT html
{{< hint info >}}
**I use the [Holocene Era or Human Era](https://en.wikipedia.org/wiki/Holocene_calendar) numbering system**. It adds exactly 10,000 years to the currently dominant AD/BC or CE/BCE numbering system. It is denoted **HE/BHE** and allows for all key dates in human history to be listed using a simle increasing date scale - while keeping the transition from the CE calendar easy: you just add the digit "1" before the current year. _Welcome to the year 12,020 HE!_
{{< /hint >}}
#+END_EXPORT

Examples:

| Human Era year | Common Era year | Event                  |
|----------------+-----------------+------------------------|
|            <r> |             <r> |                        |
|        1001 HE |        9000 BCE | [[https://en.wikipedia.org/wiki/Jericho][Jericho]]                |
|        7301 HE |        2700 BCE | [[https://en.wikipedia.org/wiki/Pyramid_of_Djoser][First pyramid]]          |
|       11460 HE |         1460 CE | [[https://en.wikipedia.org/wiki/Machu_Picchu][Machu Picchu built]]     |
|       11945 HE |         1945 CE | [[https://en.wikipedia.org/wiki/United_Nations][United Nations founded]] |

Wonderful illustration of the case for the Human Era (courtesy of
[kurzgesagt.org](https://kurzgesagt.org)):

#+BEGIN_SRC html
{{< youtube czgOWmtGVGs >}}
#+END_SRC

Structured arguments and thoughts, often presented in lists.

*Bold*, /italic/, =verbatim=, +strikethrough+

This is a test. And Hugo Book Shortcodes in an org source file:

*** Buttons
#+BEGIN_EXPORT html
{{< button relref="/" >}}Get Home{{< /button >}}
{{< button href="https://github.com/alex-shpak/hugo-book" >}}Contribute{{< /button >}}
#+END_EXPORT

*** Columns
#+BEGIN_EXPORT html
{{< columns >}}
#### Left Content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.

<--->

#### Mid Content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter!

<--->

#### Right Content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.
{{< /columns >}}

#+END_EXPORT

*** Expand
#+BEGIN_EXPORT html
{{< details "Custom Label" "..." >}}
## Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.
{{< /details >}}

#+END_EXPORT

#+begin_details
Here are the /details/.
#+end_details

#+attr_html: :open t
#+begin_details
#+begin_summary
Some *Summary*
#+end_summary
Here are the /details/.
#+end_details

*** Hints
#+BEGIN_EXPORT html
{{< hint info >}}
**Hint info**
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
{{< /hint >}}

#+END_EXPORT

#+BEGIN_EXPORT html
{{< hint warning >}}
**Hint warning**
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
{{< /hint >}}

#+END_EXPORT

#+BEGIN_EXPORT html
{{< hint danger >}}
**Hint danger**
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
{{< /hint >}}
#+END_EXPORT

*** Display Mode (KaTeX)

#+BEGIN_EXPORT html

Here is some inline example: {{< katex >}}\pi(x){{< /katex >}}, rendered in the same line. And below is `display` example, having `display: block`
{{< katex display >}}
x = \begin{cases}
   a &\text{if } b \\
   c &\text{if } d
\end{cases}
{{< /katex >}}
Text continues here.

#+END_EXPORT

This should also be possible in plain org-mode: \pi(x) vs $\pi(x)$ vs \(\pi(x)\)

This works, but requires MathJax:

\begin{equation}
\label{eq:1}
C = W\log_{2} (1+\mathrm{SNR})
\end{equation}


x = \begin{cases}
   a &\text{if } b \\
   c &\text{if } d
\end{cases}

*** Generate SVG charts and diagrams for text (Mermaid)

#+BEGIN_EXPORT html
{{< mermaid >}}
sequenceDiagram
    Alice->>Bob: Hello Bob, how are you?
    alt is sick
        Bob->>Alice: Not so good :(
    else is well
        Bob->>Alice: Feeling fresh like a daisy
    end
    opt Extra response
        Bob->>Alice: Thanks for asking
    end
{{< /mermaid >}}
#+END_EXPORT

*** Tabs
#+BEGIN_EXPORT html
{{< tabs "uniqueid" >}}
{{< tab "MacOS" >}}
# MacOS

This is tab **MacOS** content.

Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.
{{< /tab >}}

{{< tab "Linux" >}}

# Linux

This is tab **Linux** content.

Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.
{{< /tab >}}

{{< tab "Windows" >}}

# Windows

This is tab **Windows** content.

Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat
stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa
protulit, sed sed aere valvis inhaesuro Pallas animam: qui _quid_, ignes.
Miseratus fonte Ditis conubia.
{{< /tab >}}
{{< /tabs >}}

#+END_EXPORT

** TODO Science & Medicine
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_SECTION: docs/notes/kritmed
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true
:END:

** TODO Critical test section
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes/kritmed
:EXPORT_FILE_NAME: falsche-daten
:END:

*** TODO test section
Test section text.

# {{< fa github >}}

#+BEGIN_EXPORT html
{{< tabs "uniqueid" >}}
{{< tab "test" >}}

foo[^1]
[^1]: bar

{{< /tab >}}
{{< /tabs >}}
#+END_EXPORT

** TODO Other critical stuff
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes/kritmed
:EXPORT_FILE_NAME: other-critical
:END:

Here is other critical stuff.

** TODO International
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_SECTION: docs/notes/international
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true
:END:

** TODO Africa
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes/international
:EXPORT_FILE_NAME: africa
:CUSTOM_ID: africa
:END:

*** Notes on specific countries

#+BEGIN_EXPORT html
{{< tabs "uniqueid" >}}
{{< tab "Ghana" >}}

# Ghana
- [Kwame Nkrumah](https://en.wikipedia.org/wiki/Kwame_Nkrumah)[^1]
  + Pan-African while studying in America
  + returned home 11947 HE
  + founded party → slogan "Independence now!"
  + 11957 HE Independence and Accra center of independence movements
- Ashanti[^1]
  + tribe
    * e.g. Ashanti, consists of 8 clans
    * king: _Ashantehene_
    * territorial, cultural, political community
  + clan → all those who believe they have a common ancestor
    * secual relations between clan-members forbidden!
  + clan chief
    * voted for by council (elders, functionaries, ...)
    * because holy person in moment of election → no walking barefoot, others may not touch him, ...
    * main task: communication between ancestors and living
    * has to step down, if: drunk, gluttoning, collusion with sorceror, bad speech about people, not asking elders about opinions


[^1]: Kapuscinski, Ryszard. The Shadow of the Sun. Penguin, 2002.


{{< /tab >}}

{{< tab "Tansania" >}}

# Zanzibar
## Mid 120th-century
- "sad, dark star". Arabs from Persian Gulf conquered island with best stretches of land + hotspot of [Arab slave trade](https://en.wikipedia.org/wiki/Arab_slave_trade)[^1]
- population[^1]
  + 20% ruling Arabs
    * ruler: Sultan
    * want independence from Britain
  + 80% laboring Africans
    * [Afro-Shirazi Party (ASP)]([https://en.wikipedia.org/wiki/Afro-Shirazi_Party) headed by [Karume](https://en.wikipedia.org/wiki/Abeid_Karume) + [John Okello](https://en.wikipedia.org/wiki/John_Okello) (revolutionary)
    * want independence from Britain AND Arabs

[^1]: Kapuscinski, Ryszard. The Shadow of the Sun. Penguin, 2002.


{{< /tab >}}

{{< tab "Ethiopia" >}}

# Ethiopia
- emperor [Haile Selassi](https://en.wikipedia.org/wiki/Haile_Selassie) in power till 11974 HE.
- dictator [Mengistu Haile Mariam](https://en.wikipedia.org/wiki/Mengistu_Haile_Mariam) in power 11974 - 11991 HE.
- 11983-85 HE: [great famine](https://en.wikipedia.org/wiki/1983%E2%80%931985_famine_in_Ethiopia) with around 1 Mio. hunger deaths - why?
  + great famine was not result of shortage, but of inhumane relations
  + there was food in the country, but when drought came, prices went up and poor peasents were unable to purchase any
  + government did not intervene / let world intervene, because: prestige, didn't want to admit that there was hunger in the land
{{< /tab >}}
{{< /tabs >}}

#+END_EXPORT

*** Phases after WWII
**** 1st phase: 50s/60s - rapid decolonization, optimism, euphoria
- promise and hope, with freedom comes prosperity
- movement of French colonies \to want to become French citizens
- movement of British colonies \to *Pan-Africanism*
  + people: activist [[https://en.wikipedia.org/wiki/Alexander_Crummell][Alexander Crummell]], writer [[https://en.wikipedia.org/wiki/W._E._B._Du_Bois][W. E. B. Du Bois]] (core idea:
    Black* people should remain in the countries where they now live), journalist
    [[https://en.wikipedia.org/wiki/Marcus_Garvey][Marcus Garvey]] (core idea: Black* people should return to Africa)
  + core ideas
    1. all Blacks* in the world constitute a single race, a single culture, and
       should be proud of their colour of skin
    2. all of Africa should be independent and united \to "Africa for Africans"
- BUT: corrupt elites - why?
  + no well-developed private sector, plantations belonged to foreigners, banks
    belong to foreign capital \to political career was only way to richness
**** 2nd phase: 70s/80s - rapid growth of population, pessimism
- civil wars, revolts, massacres, hunger
  + opponents used all means (tribal and ethnic conflicts, military might,
    corruption, murder)
  + cold war era → problems + interests of weaker, dependent countries were
    ignored, subordinate to superpower interests
- coup d'etat in /Nigeria/ - military seizes power after only 5 years of
  independence
  + and people celebrate! Since own elite is seen as too corrupt ("black
    imperialists", "political wolves, who plunder the country")

** TODO Asia
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes/international
:EXPORT_FILE_NAME: asia
:END:

Another continent to describe.

** TODO Section Philosophy
:PROPERTIES:
:EXPORT_FILE_NAME: _index.en.md
:EXPORT_HUGO_SECTION: docs/notes/philosophy
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true
:END:

** TODO Philosophy
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes/philosophy
:EXPORT_FILE_NAME: philo.en.md
:END:
*** A overview from
#+BEGIN_EXPORT html
{{< mermaid >}}
graph TD
	A["Christmas und viel mehr text hahaha textext<br/>
  und noch mehr text"] -->|Get money| B(Go shopping)
	B --> C{Let me think}
	C -->|One| D[Laptop]
	C -->|Two| E[iPhone]
	C -->|Three| F[fa:fa-car Car]

{{< /mermaid >}}
#+END_EXPORT

* Notizen
:PROPERTIES:
:EXPORT_HUGO_SECTION: docs/notes
:END:
** Notizen
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index.de.md
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookCollapseSection false
   :END:
** Gedichte
   :PROPERTIES:
   :EXPORT_FILE_NAME: poetry.de.md
   :END:
*** Erich Fried
   #+begin_details
   #+begin_summary
   Kleines Beispiel (1982)
   #+end_summary
   #+BEGIN_VERSE
     Auch ungelebtes Leben
     geht zu Ende
     zwar vielleicht langsamer
     wie eine Batterie
     in einer Taschenlampe
     die keiner benutzt

     Aber das hilft nicht viel:
     Wenn man
     (sagen wir einmal)
     diese Taschenlampe
     nach so- und sovielen Jahren
     anknipsen will
     kommt kein Atemzug Licht mehr heraus
     und wenn du sie aufmachst
     findest du nur deine Knochen
     und falls du Pech hast
     auch diese
     schon ganz zerfressen

     Da hättest du
     genau so gut
     leuchten können
   #+END_VERSE
   #+end_details

   #+begin_details
   #+begin_summary
   Herrschaftsfreiheit (1984)
   #+end_summary
   #+BEGIN_VERSE
     Zu sagen
     "Hier
     herrscht Freiheit"
     ist immer
     ein Irrtum
     oder auch
     eine Lüge:

     Freiheit
     herrscht nicht
   #+END_VERSE
   #+end_details

   #+begin_details
   #+begin_summary
   Humorlos (1967)
   #+end_summary
   #+BEGIN_VERSE
     Die Jungen
     werfen
     zum Spaß
     mit Steinen
     nach Fröschen

     Die Frösche
     sterben
     im Ernst
   #+END_VERSE
   #+end_details

   #+begin_details
   #+begin_summary
   Rückwärtsgewandte Utopie (1981)
   #+end_summary
   #+BEGIN_VERSE
     Angeklagt
     der Unmenschlichkeit
     behauptet
     der Nichtmehrmensch
     immer noch
     erst
     ein Nochnichtmensch
     zu sein
   #+END_VERSE
   #+end_details

   #+begin_details
   #+begin_summary
   Zu guter Letzt (1983)
   #+end_summary
   #+BEGIN_VERSE
     Als Kind wusste ich:
     Jeder Schmetterling
     den ich rette
     jede Schnecke
     und jede Spinne
     und jede Mücke
     jeder Ohrwurm
     und jeder Regenwurm
     wird kommen und weinen
     wenn ich begraben werde

     Einmal von mir gerettet
     muss keines mehr sterben
     Alle werden sie kommen
     zu meinem Begräbnis

     Als ich dann groß wurde
     erkannte ich:
     Das ist großer Unsinn
     Keines wird kommen
     ich überlebe sie alle

     Jetzt im Alter
     frage ich: Wenn ich sie aber
     rette bis ganz zuletzt
     kommen doch vielleicht zwei oder drei?
   #+END_VERSE
   #+end_details

*** Lǎozǐ
    Ich persönlich mag die Übersetzung von Günther Debon.
   #+begin_details
   #+begin_summary
   Dàodéjīng - Kapitel 11
   #+end_summary
   #+BEGIN_VERSE
     [...]

     Man knetet Ton zurecht
     Zum Trinkgerät:
     Eben dort, wo keiner ist,
     Ist des Gerätes Brauchbarkeit.

     [...]

     Wahrlich:
     Erkennst du das Da-Sein als einen Gewinn,
     Erkenne: Das Nicht-Sein macht brauchbar.
   #+END_VERSE
   #+end_details
   #+begin_details
   #+begin_summary
   Dàodéjīng - Kapitel 15
   #+end_summary
   #+BEGIN_VERSE
     Wer im Altertum gut war als Meister,
     War subtil, geheimnisvoll, mystisch, durchdringend;
     So tief, dass er uns unbegreiflich bleibt.
     Wohl! Und weil er unbegreiflich bleibt,
     Will ich lieber dartun sein Gebaren:

     So zögernd, ach!
     Wie wenn man winters quert einen Strom;
     So ängstlich, ach!
     Wie wenn man fürchtet die Nachbarn rings;
     Verhalten, ach!
     Als wäre zu Gast man geladen;
     Nachgiebig, ach!
     Wie vor der Schmelze das Eis;
     Gediegen, ach!
     Gleich einem Grobholz;
     Weit, ach!
     Gleich einem Flusstal;
     Chaotisch, ach!
     Gleich einem Strudel.

     Wer kann den Strudel stillen,
     Auf dass er mählich werde rein?
     Wer kann das Ruhende bewegen,
     Auf dass es mählich Leben gewinne?

     Wer diesen <i>Weg</i> bewahrt,
     Wünscht nicht, erfüllt zu sein.
     Wohl! Nur was unerfüllt,
     Kann auch verschleißen ohne Erneuen.
   #+END_VERSE
   #+end_details
   #+begin_details
   #+begin_summary
   Dàodéjīng - Kapitel 20
   #+end_summary
   #+BEGIN_VERSE
     Brich ab das Lernen, so bist du sorgenfrei!

     Sind denn "Jawohl!" und "Recht gern!"
     Wirklich einander so fern?
     Sind denn das Gute, die Schlechtigkeit
     Wirklich einander so weit?
     "Wem andere Menschen sich beugen,
     Dem musst auch du dich beugen":
     Welch Öde doch! Und kein Ende noch!

     Die Menschen alle sind ausgelassen,
     Als säßen sie zechend beim Opferfest,
     Als stiegen sie auf zu den Frühlingsterrassen.
     Ich allein liege noch still,
     Kein Zeichen hab ich gegeben,
     Gleich einem kleinen Kinde,
     Das noch nie gelacht hat im Leben;
     Bin schwankend, bin wankend,
     Als hätt ich die Heimat verloren.
     Die Menge der Menschen hat Überfluss;
     Nur Ich bin gleichsam von allem entblößt.
     Wahrlich, Ich habe das Herz eines Toren,
     So dunkel und wirr!
     Die gewöhnlichen Menschen sind hell und klar;
     Nur Ich bin trübe verhangen.
     Die gewöhnlichen Menschen sind strebig-straff;
     Nur Ich bin bang-befangen.
     Ruhelos gleich ich dem Meere;
     Verweht, ach, bin gleichsam ich ohne Halt.

     Die Menschen machen sich nützlich all,
     Nur Ich bin halsstarr, als ob ich ein Wildling wäre.
     Nur Ich bin von den andern Menschen verschieden -
     Der ich die nährende Mutter verehre.
   #+END_VERSE
   #+end_details

** Poetry
   :PROPERTIES:
   :EXPORT_FILE_NAME: poetry.en.md
   :END:
*** Lǎozǐ
    I am partial to the [[https://terebess.hu/english/tao/DerekLin.html#Kap20][translation of Derek Lin]]
   #+begin_details
   #+begin_summary
   Dàodéjīng - Chapter 11 (The use of what has no substantive existence)
   #+end_summary
   #+BEGIN_VERSE
     [...]

     Mix clay
     to create a container
     In its emptiness, there is
     the function of a container

     [...]
     Therefore,
     that which exists is used to create benefit
     That which is empty is used to create functionality
   #+END_VERSE
   #+end_details
   #+begin_details
   #+begin_summary
   Dàodéjīng - Chapter 15 (The exhibition of the qualities of the Dao)
   #+end_summary
   #+BEGIN_VERSE
     The Tao masters of antiquity
     Subtle wonders through mystery
     Depths that cannot be discerned
     Because one cannot discern them
     Therefore one is forced to describe the appearance

     Hesitant,
     like crossing a wintry river
     Cautious,
     like fearing four neighbors
     Solemn,
     like a guest
     Loose,
     like ice about to melt
     Genuine,
     like plain wood
     Open,
     like a valley
     Opaque,
     like muddy water

     Who can be muddled yet desist
     In stillness gradually become clear?
     Who can be serene yet persist
     In motion gradually come alive?

     One who holds this <i>Tao</i> does not wish to be overfilled
     Because one is not overfilled
     Therefore one can preserve and not create anew
   #+END_VERSE
   #+end_details
   #+begin_details
   #+begin_summary
   Dàodéjīng - Chapter 20 (Being different from ordinary people)
   #+end_summary
   #+BEGIN_VERSE
     Cease learning, no more worries

     Respectful response and scornful response
     How much is the difference?
     Goodness and evil
     How much do they differ?
     What the people fear,
     I cannot be unafraid
     So desolate! How limitless it is!

     The people are excited
     As if enjoying a great feast
     As if climbing up to the terrace in spring
     I alone am quiet and uninvolved
     Like an infant
     not yet smiling
     So weary,
     like having no place to return
     The people all have surplus
     While I alone seem lacking
     I have the heart of a fool indeed -
     so ignorant!
     Ordinary people are bright
     I alone am muddled
     Ordinary people are scrutinizing
     I alone am obtuse
     So tranquil, like the ocean
     So moving, as if without limits

     The people all have goals
     And I alone am stubborn and lowly
     I alone am different from them
     And value the nourishing mother
   #+END_VERSE
   #+end_details
** TODO Sektion Philosopie
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index.de.md
   :EXPORT_HUGO_SECTION: docs/notes/philosophy
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :bookFlatSection true
   :END:

** TODO Philosopie
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: docs/notes/philosophy
   :EXPORT_FILE_NAME: philo.de.md
   :END:
*** Ein Überblick aus "Sophies Welt"
#+BEGIN_EXPORT html
{{< mermaid >}}
graph TB
10(("""mythisches Weltbild<br>
   = Göttererzählungen"""))
11["""
- Präkere <sup>Machtbalance</sup> zw. guten<br>
  und bösen Kräften<br>
- Natur = <i>Frøya</i>, wenn geraubt<br>
  von Trollen keine <sub>Fruchtbarkeit</sub><br>
- Opfer um <code>Macht</code> der <del>Götter</del> zu<br>
  vergrößern → f. Odin sogar Menschen<br>
- Gedicht <i>Trymsveda</i>: Thor's<br>
  <q>Hammer gestohlen</q> → verkleidet sich als Frau<br>
  um ihn wiederzubekommen<br>
"""]
12["""
- <big>Niederschrift</big> der <small>Göttermythen</small> dr<br>
  <b>Homer</b> und <b>Hesiod</b> 9300 HE<br>
- 1. Mythenkritik: <strong>Xenophanes</strong> 9430 HE<br>
  ...Götter nach eigenem Vorbild...<br>
  → Ziel erster Philosophen: natürliche<br>
  Erklärungen für Naturprozesse<br>
"""]
20(("""Naturphilosophen (Vorsokratiker)<br>
- sahen <u>Veränderungen</u><br>
- glaubten an Urstoff dahinter<br>
- erhalten durch Aristoteles<br>
"""))
21["""<big>3 aus Milet (griech. Kolonie in Kleinasien)</big>"""]
21a["""
- Urstoff = <u>Wasser</u><br>
- Erde voller <q>Lebenskeime</q>,<br>
  alles voller Götter<br>
- 9415 HE Sonnenfinsternis berechnet<br>
"""]
21b["""
- Welt nur eine von vielen<br>
- entsteht und vergeht in<br>
  <u>das Unendliche</u>
"""]
21c["""
- 9430 - 9475 HE<br>
- Urstoff = <u>Luft</u><br>
- Wasser ist dichte Luft,<br>
  Feuer ist dünne Luft
"""]
22["""<strong>Parmenides</strong> (9460 - 9520 HE)<br>
- alles, was es gibt, hat schon immer existiert<br>
- aus nichts kann nichts werden <br>
- glaubte nicht an Veränderung<br>
  → <u>Sinnestäuschung</u><br>
- starker Glaube an menschliche <u>Vernunft</u><br>
  = <u>Rationalismus</u>
"""]
23["""<strong>Heraklit</strong> (9460 - 9520 HE)<br>
- alles fließt → <u>Sinneserfahrung</u><br>
- Gut und Böse hat Platz in Ganzheit<br>
- alle Veränderung und Gegensätze der Natur<br>
  sind <u>Einheit oder Ganzheit</u><br>
  = Gott oder <u>Logos</u>
"""]
24["""<strong>Anaxagoras</strong> (9500 - 9573 HE)<br>
- nicht 1 Urstoff, sondern<br>
  kleinste Teilchen, die<br>
  <q>etwas von allem</q> in sich<br>
  tragen = <q>Samen / Keime</q><br>
- 1 Kraft, die Ordnung schafft<br>
  = <u>Geist</u><br>
- Astronom:<br>
  - Sonne kein Gott, sondern<br>
    glühende Masse<br>
  - alle Himmelskörper aus Stoff<br>
    wie unsere Erde → <u>Leben auf</u><br>
    <u> anderen Planete</u> mögl<br>
  - erklärte Entstehung von<br>
    Sonnenfinsternissen
"""]
25["""<strong>Empedokles</strong> (9507 - 9567 HE)<br>
- Fehler liegt in Annahme<br>
  <u>1</u> Grundstoffes<br>
- 4 <u>Wurzeln</u> der Natur<br>
  = Erde, Luft, Feuer, Wasser<br>
- 2 <u>Naturkräfte</u>:<br>
  Liebe und Streit;<br>
  auflösen und verbinden<br>
→ Unterscheidet zw <u>Stoff</u><br>
  und <u>Kraft</u> → moderne<br>
  Wissenschaft glaubt auch, alles<br>
  dr Grundstoffe + Naturkräfte<br>
  erklären zu können
"""]
26["""<strong>Demokrit</strong> (9541 - 9631 HE)<br>
- sichtbare Veränderung heißt<br>
  nicht, dass sich wirklich<br>
  etwas veränderte → kleine,<br>
  unteilbare, unsichtbare,<br>
  feste/massive, unterschiedlich<br>
  geformte, ewige, mit <q>Haken u<br>
  Ösen</q> ausgestattete Bau-<br>
  steine = <u>Atome</u> → noch heute<br>
  wird an kleinste Teile geglaubt<br>
- glaubte nur an Atome = das<br>
  Materielle + leerer Raum<br>
  = <u>Materialist</u><br>
- Empfindungen auch durch Atome<br>
  (<q>Mondatome treffen mein Auge</q>)<br>
- Bewusstsein? → Seelenatome<br>
  → stirbt Mensch, wirbeln<br>
  Seelenatome davon → keine<br>
  unsterbliche Seele
"""]
27["""
→ Wie konnte ein Stoff plötzlich zu etwas anderen<br>
  werden? → <u>Problem der Veränderung</u>
"""]

30(("""Schicksalsgläubigkeit"""))

40(("""<u>Sophisten</u><br>
in Athen ab 9550 HE"""))

50(("""Athener Philosophie / Die Sokratiker<br>
ca 9550 - 9650 HE"""))

60(("""<u>Hellenismus</u><br>
ca 9650 - 9950 HE"""))

10==>20
subgraph Göttererzählungen
10-->|Wikinger|11
10-->|Griechen|12
end
11-.-20
12-.-20
20==>30
subgraph Vorsokratiker
20-->21
21-->|<strong>Thales</strong>|21a
21-->|<strong>Anaximander</strong>|21b
21-->|<strong>Anaximenes</strong>|21c
21a-->27
21b-->27
21c-->27
subgraph Problem-der-Veränderung
27-->|Eleaten-in-Süditalien|22
27-->|Ephesos-in-Kleinasien|23
end
subgraph Lösungen
22-->|Lösung|24
22-->|Lösung|25
23-->|Lösung|25
22-->|beste Lösung: in Abdera an nördlicher Ägäis|26
end
end
24-.-30
25-.-30
26-.-30
30==>40
40==>50
50==>60

{{< /mermaid >}}
#+END_EXPORT

* Blog Posts
# the blog posts are displayed by a simple html list and inserted before the
# menu main thanks to /themes/book/layouts/partials/docs/inject/menu-before.html
:PROPERTIES:
:EXPORT_HUGO_SECTION: posts
:END:
** TODO Test post
   CLOSED: [2020-03-23 Mo 14:31]
:PROPERTIES:
:EXPORT_FILE_NAME: test-post.en.md
:END:

Test post text.

** TODO Test post deutsch
   CLOSED: [2020-03-23 Mo 14:31]
:PROPERTIES:
:EXPORT_FILE_NAME: test-post.de.md
:END:

Test post text.
** DONE Advent of code 2023 - Day 1: Trebuchet?! :python:
CLOSED: [2023-12-10 So 03:05]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day01.en.md
:header-args:jupyter-python: :session /jpy:localhost#8888:a37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both +n
:ID:       050c869e-41c1-4428-85ef-dcd83cf0b8d7
:END:

This year I try to record my attempt at solving the *Advent of Code 2023*
riddles. This is Day 1 - see [[https:adventofcode.com/2023/day/1]]

*** Part 1
Our first task is the following:

#+begin_quote
The newly-improved calibration document consists of lines of text; each line
originally contained a specific calibration value that the Elves now need to
recover. On each line, the calibration value can be found by combining the first
digit and the last digit (in that order) to form a single two-digit number.

For example:
#+end_quote

#+begin_example
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
#+end_example

#+begin_quote
In this example, the calibration values of these four lines are 12, 38, 15,
and 77. Adding these together produces 142.

Consider your entire calibration document. What is the sum of all of the
calibration values?
#+end_quote

Lets start jupyter in our shell to start coding!

#+begin_src sh :session local :noeval
  conda activate tf
  jupyter lab --no-browser --port=8888
#+end_src

First, load the test document

#+BEGIN_SRC jupyter-python
  import pandas as pd
  import re

  txt = pd.read_table('data/2023-12-01-1-aoc.txt', names=['code'])
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                              code
0                   jjfvnnlfivejj1
1                        6fourfour
2                    ninevbmltwo69
3         pcg91vqrfpxxzzzoneightzt
4    jpprthxgjfive3one1qckhrptpqdc
..                             ...
995       583sevenhjxlqzjgbzxhkcl5
996                            81s
997        2four3threesxxvlfqfive4
998        nine6eightsevenzx9twoxc
999    hmbfjdfnp989mfivefiverpzrjs

[1000 rows x 1 columns]
#+end_example

Second, extract the digits. I had to wrap my head around regex matching in
python first, because I first tried =pandas.extract= (which only extracts the
first match), then =pandas.extractall= (which extracts all matches but puts them
into a multiindex which makes things more difficult in this case). So I settled
for the =re.findall= version, which returns a list. To concatenate the elements
in the list, we take use the =join= function.

#+BEGIN_SRC jupyter-python
  txt['digits'] = txt.loc[:, 'code'].apply(
      lambda x: ''.join(re.findall(r'(\d+)', x)))
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                              code digits
0                   jjfvnnlfivejj1      1
1                        6fourfour      6
2                    ninevbmltwo69     69
3         pcg91vqrfpxxzzzoneightzt     91
4    jpprthxgjfive3one1qckhrptpqdc     31
..                             ...    ...
995       583sevenhjxlqzjgbzxhkcl5   5835
996                            81s     81
997        2four3threesxxvlfqfive4    234
998        nine6eightsevenzx9twoxc     69
999    hmbfjdfnp989mfivefiverpzrjs    989

[1000 rows x 2 columns]
#+end_example

Next, combine the first and the last digit and convert the result from string to integer

#+BEGIN_SRC jupyter-python
  txt['calibration'] = txt.loc[:, 'digits'].apply(
      lambda x: int(x[0] + x[-1]))
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                              code digits  calibration
0                   jjfvnnlfivejj1      1           11
1                        6fourfour      6           66
2                    ninevbmltwo69     69           69
3         pcg91vqrfpxxzzzoneightzt     91           91
4    jpprthxgjfive3one1qckhrptpqdc     31           31
..                             ...    ...          ...
995       583sevenhjxlqzjgbzxhkcl5   5835           55
996                            81s     81           81
997        2four3threesxxvlfqfive4    234           24
998        nine6eightsevenzx9twoxc     69           69
999    hmbfjdfnp989mfivefiverpzrjs    989           99

[1000 rows x 3 columns]
#+end_example

Lastly, get the sum of our calibration numbers

#+BEGIN_SRC jupyter-python
  txt.loc[:, 'calibration'].sum()
#+END_SRC

#+RESULTS:
: 56465

*** Part 2
Now follows part two:

#+begin_quote
Your calculation isn't quite right. It looks like some of the digits are
actually spelled out with letters: one, two, three, four, five, six, seven,
eight, and nine also count as valid "digits".

Equipped with this new information, you now need to find the real first and last
digit on each line. For example:
#+end_quote

#+begin_example
two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
#+end_example

#+begin_quote
In this example, the calibration values are 29, 83, 13, 24, 42, 14, and 76.
Adding these together produces 281.

What is the sum of all of the calibration values?
#+end_quote

Okay, let's see if we can update the pattern matching. To deal with potential
overlapping values like =oneight= which contains =one= as well as =eight=, I
used the regex positive lookahead ~?=~ as described [[https://stackoverflow.com/a/5616910][here]]. Because this enables
capturing overlapping values, I used =\d= (one digit) instead of =\d+= (one or
more digits), otherwise digits might double. Afterwards, just replace the
spelled out digits with their numerical value.

#+begin_src jupyter-python
  # for i, r in enumerate(txt.loc[:, 'code']):
  #     matches = re.findall(
  #         r'(?=(\d|one|two|three|four|five|six|seven|eight|nine))', r)
  #     result = ''.join([match for match in matches])
  #     result = result.replace('one', '1').replace('two', '2').replace(
  #         'three', '3').replace('four', '4').replace('five', '5').replace(
  #         'six', '6').replace('seven', '7').replace('eight', '8').replace(
  #         'nine', '9')
  #     txt.loc[i, 'digits2'] = result
  # txt

  # a very nice alternative suggested by Tomalak:
  digits = '\d one two three four five six seven eight nine'.split()


  txt['digits2'] = txt.loc[:, 'code'].apply(lambda v: ''.join(
      str(digits.index(m)) if m in digits else m
      for m in re.findall(rf'(?=({"|".join(digits)}))', v)
  ))
  txt
#+end_src

#+RESULTS:
#+begin_example
                              code digits  calibration digits2
0                   jjfvnnlfivejj1      1           11      51
1                        6fourfour      6           66     644
2                    ninevbmltwo69     69           69    9269
3         pcg91vqrfpxxzzzoneightzt     91           91    9118
4    jpprthxgjfive3one1qckhrptpqdc     31           31    5311
..                             ...    ...          ...     ...
995       583sevenhjxlqzjgbzxhkcl5   5835           55   58375
996                            81s     81           81      81
997        2four3threesxxvlfqfive4    234           24  243354
998        nine6eightsevenzx9twoxc     69           69  968792
999    hmbfjdfnp989mfivefiverpzrjs    989           99   98955

[1000 rows x 4 columns]
#+end_example

Now, construct the calibration value as before...

#+BEGIN_SRC jupyter-python
  txt['calibration2'] = txt.loc[:, 'digits2'].apply(lambda x: int(x[0] + x[-1]))
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                              code digits  calibration digits2  calibration2
0                   jjfvnnlfivejj1      1           11      51            51
1                        6fourfour      6           66     644            64
2                    ninevbmltwo69     69           69    9269            99
3         pcg91vqrfpxxzzzoneightzt     91           91    9118            98
4    jpprthxgjfive3one1qckhrptpqdc     31           31    5311            51
..                             ...    ...          ...     ...           ...
995       583sevenhjxlqzjgbzxhkcl5   5835           55   58375            55
996                            81s     81           81      81            81
997        2four3threesxxvlfqfive4    234           24  243354            24
998        nine6eightsevenzx9twoxc     69           69  968792            92
999    hmbfjdfnp989mfivefiverpzrjs    989           99   98955            95

[1000 rows x 5 columns]
#+end_example

... and get the correct sum!

#+BEGIN_SRC jupyter-python
  txt.loc[:, 'calibration2'].sum()
#+END_SRC

#+RESULTS:
: 55902

** DONE Advent of code 2023 - Tag 1: Trebuchet?! :python:
CLOSED: [2023-12-11 Mo 23:38]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day01.de.md
:END:

Dieses Jahr versuche ich mich an den Herausforderungen des *Advent of Code
2023*. Dies ist Tag 1 - siehe [[https:adventofcode.com/2023/day/1]]

** DONE Advent of code 2023 - Day 2: Cube Conundrum :python:
CLOSED: [2023-12-11 Mo 23:38]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day02.en.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both +n
:END:

This year I try to record my attempt at solving the *Advent of Code 2023*
riddles. This is Day 2 - see [[https:adventofcode.com/2023/day/2]]
*** Part 1
Lets first read the task:

#+begin_quote
As you walk, the Elf shows you a small bag and some cubes which are either red,
green, or blue. Each time you play this game, he will hide a secret number of
cubes of each color in the bag, and your goal is to figure out information about
the number of cubes.

To get information, once a bag has been loaded with cubes, the Elf will reach
into the bag, grab a handful of random cubes, show them to you, and then put
them back in the bag. He'll do this a few times per game.

You play several games and record the information from each game (your puzzle
input). Each game is listed with its ID number (like the =11= in =Game 11: ...=)
followed by a semicolon-separated list of subsets of cubes that were revealed
from the bag (like =3 red, 5 green, 4 blue=).

For example, the record of a few games might look like this:
#+end_quote

#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

#+begin_quote
In game 1, three sets of cubes are revealed from the bag (and then put back
again). The first set is 3 blue cubes and 4 red cubes; the second set is 1 red
cube, 2 green cubes, and 6 blue cubes; the third set is only 2 green cubes.

The Elf would first like to know which games would have been possible if the bag
contained *only 12 red cubes, 13 green cubes, and 14 blue cubes*?

In the example above, games 1, 2, and 5 would have been possible if the bag had
been loaded with that configuration. However, game 3 would have been impossible
because at one point the Elf showed you 20 red cubes at once; similarly, game 4
would also have been impossible because the Elf showed you 15 blue cubes at
once. If you add up the IDs of the games that would have been possible, you
get =8=.

Determine which games would have been possible if the bag had been loaded with
only 12 red cubes, 13 green cubes, and 14 blue cubes. *What is the sum of the IDs
of those games*?
#+end_quote

Okay, let's load our python kernel in emacs-jupyter and get coding! First of
all, let's load the input and split the riddle code by colon =:= to extract the
game id and the rest of the code by semicolon =;= to get the number of sets
played in each game.

#+BEGIN_SRC jupyter-python
  import pandas as pd
  import re

  txt = pd.read_table('data/2023-12-02-1-aoc.txt', names=['code'])
  txt['id'] = txt.loc[:, 'code'].str.split(':').apply(
      lambda x: int(x[0].strip('Game ')))
  txt['code'] = txt.loc[:, 'code'].str.split(':').apply(lambda x: x[1])
  # txt['code'] = txt.loc[:, 'code'].str.split(';')
  # txt['nsets'] = txt.loc[:, 'code'].apply(lambda x: len(x))
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                                                 code   id
0    1 green, 1 blue, 1 red; 1 green, 8 red, 7 blu...    1
1    9 red, 7 green, 3 blue; 15 green, 2 blue, 5 r...    2
2    3 red, 1 blue, 4 green; 6 red, 3 green, 2 blu...    3
3    2 blue, 2 green, 19 red; 3 blue, 11 red, 16 g...    4
4    8 green, 1 red, 12 blue; 10 green, 6 red, 13 ...    5
..                                                ...  ...
95    2 red, 2 green, 1 blue; 1 red, 4 green; 1 green   96
96   4 red, 5 green; 5 blue, 3 red; 8 blue, 2 gree...   97
97   1 blue; 2 green, 1 red; 5 red, 2 green; 4 red...   98
98   6 blue, 5 red, 2 green; 9 red, 1 blue; 2 gree...   99
99   1 blue, 13 green, 14 red; 11 green, 11 blue, ...  100

[100 rows x 2 columns]
#+end_example

Now, let's extract the three colors in different columns with regex. We use the
lookahead assertion ~?=~ to find the respective colours and only exctract the
digits =\d+= coming before. Then we just keep the =max= imum drawn number of cubes
per color, since this is the only information that matters at the moment.

#+BEGIN_SRC jupyter-python
  txt['green'] = txt.loc[:, 'code'].apply(
      lambda code: re.findall(r'\d+(?=.green)', code)).apply(
          lambda list: max([int(i) for i in list]))
  txt['red'] = txt.loc[:, 'code'].apply(
      lambda code: re.findall(r'\d+(?=.red)', code)).apply(
          lambda list: max([int(i) for i in list]))
  txt['blue'] = txt.loc[:, 'code'].apply(
      lambda code: re.findall(r'\d+(?=.blue)', code)).apply(
          lambda list: max([int(i) for i in list]))
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                                                 code   id  green  red  blue
0    1 green, 1 blue, 1 red; 1 green, 8 red, 7 blu...    1      2   10    10
1    9 red, 7 green, 3 blue; 15 green, 2 blue, 5 r...    2     15   10     3
2    3 red, 1 blue, 4 green; 6 red, 3 green, 2 blu...    3      4    6    16
3    2 blue, 2 green, 19 red; 3 blue, 11 red, 16 g...    4     16   20    18
4    8 green, 1 red, 12 blue; 10 green, 6 red, 13 ...    5     10    6    14
..                                                ...  ...    ...  ...   ...
95    2 red, 2 green, 1 blue; 1 red, 4 green; 1 green   96      4    2     1
96   4 red, 5 green; 5 blue, 3 red; 8 blue, 2 gree...   97      5    4     8
97   1 blue; 2 green, 1 red; 5 red, 2 green; 4 red...   98      2    5     2
98   6 blue, 5 red, 2 green; 9 red, 1 blue; 2 gree...   99      2    9    11
99   1 blue, 13 green, 14 red; 11 green, 11 blue, ...  100     13   15    11

[100 rows x 5 columns]
#+end_example

Lastly, we just filter the DataFrame to only include games where all drawn cubes
were below or equal the number of cubes in the game and sum the result!

#+BEGIN_SRC jupyter-python
  txt['id'][(txt['green'] < 14) & (txt['red'] < 13) & (txt['blue'] < 15)].sum()
#+END_SRC

#+RESULTS:
: 3035

*** Part 2
First, let's get the instruction from the second part:
#+begin_quote
As you continue your walk, the Elf poses a second question: in each game you
played, what is the fewest number of cubes of each color that could have been in
the bag to make the game possible?

Again consider the example games from earlier:
#+end_quote

#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

#+begin_quote
- In game 1, the game could have been played with as few as 4 red, 2 green, and
  6 blue cubes. If any color had even one fewer cube, the game would have been
  impossible.
- Game 2 could have been played with a minimum of 1 red, 3 green, and 4 blue
  cubes.
- Game 3 must have been played with at least 20 red, 13 green, and 6 blue cubes.
- Game 4 required at least 14 red, 3 green, and 15 blue cubes.
- Game 5 needed no fewer than 6 red, 3 green, and 2 blue cubes in the bag.

The *power* of a set of cubes is equal to the numbers of red, green, and blue
cubes multiplied together. The power of the minimum set of cubes in game 1
is 48. In games 2-5 it was 12, 1560, 630, and 36, respectively. Adding up these
five powers produces the sum 2286.

For each game, find the minimum set of cubes that must have been present. *What
is the sum of the power of these sets?*
#+end_quote

Luckily, this task is made trivial by the approach we have taken before. We just
have to multiply the =green=, =red= and =blue= columns:

#+BEGIN_SRC jupyter-python
  txt['power'] = txt.loc[:, 'green'] * txt.loc[:, 'blue'] * txt.loc[:, 'red']
  txt
#+END_SRC

#+RESULTS:
#+begin_example
                                                 code   id  green  red  blue  \
0    1 green, 1 blue, 1 red; 1 green, 8 red, 7 blu...    1      2   10    10
1    9 red, 7 green, 3 blue; 15 green, 2 blue, 5 r...    2     15   10     3
2    3 red, 1 blue, 4 green; 6 red, 3 green, 2 blu...    3      4    6    16
3    2 blue, 2 green, 19 red; 3 blue, 11 red, 16 g...    4     16   20    18
4    8 green, 1 red, 12 blue; 10 green, 6 red, 13 ...    5     10    6    14
..                                                ...  ...    ...  ...   ...
95    2 red, 2 green, 1 blue; 1 red, 4 green; 1 green   96      4    2     1
96   4 red, 5 green; 5 blue, 3 red; 8 blue, 2 gree...   97      5    4     8
97   1 blue; 2 green, 1 red; 5 red, 2 green; 4 red...   98      2    5     2
98   6 blue, 5 red, 2 green; 9 red, 1 blue; 2 gree...   99      2    9    11
99   1 blue, 13 green, 14 red; 11 green, 11 blue, ...  100     13   15    11

    power
0     200
1     450
2     384
3    5760
4     840
..    ...
95      8
96    160
97     20
98    198
99   2145

[100 rows x 6 columns]
#+end_example

And for this one, the sum is:

#+BEGIN_SRC jupyter-python
  txt['power'].sum()
#+END_SRC

#+RESULTS:
: 66027

** DONE Advent of code 2023 - Tag 2: Würfelrätsel :python:
CLOSED: [2023-12-11 Mo 23:38]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day02.de.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

Dieses Jahr versuche ich mich an den Herausforderungen des *Advent of Code
2023*. Dies ist Tag 2 - siehe [[https:adventofcode.com/2023/day/2]]

Für die Lösungen siehe die englische Version dieses Blogbeitrages.
** DONE Advent of code 2023 - Day 3: Gear Ratios :python:
CLOSED: [2023-12-18 Mo 01:01]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day03.en.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

This year I try to record my attempt at solving the *Advent of Code 2023*
riddles. This is Day 3 - see [[https:adventofcode.com/2023/day/3]]
*** Part 1
Lets first read the task:

#+begin_quote
The engine schematic (your puzzle input) consists of a visual representation of
the engine. There are lots of numbers and symbols you don't really understand,
but apparently *any number adjacent to a symbol*, even diagonally, is a "part
number" and should be included in your sum. (Periods (=.=) do not count as a
symbol.)

Here is an example engine schematic:
#+end_quote

#+begin_example
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
#+end_example

#+begin_quote
In this schematic, two numbers are not part numbers because they are not
adjacent to a symbol: =114= (top right) and =58= (middle right). Every other
number is adjacent to a symbol and so is a part number; their sum is =4361=.

Of course, the actual engine schematic is much larger. *What is the sum of all of
the part numbers in the engine schematic*?
#+end_quote

Okay, let's first get the input as a =numpy= character array

#+begin_src jupyter-python
  import numpy as np
  import pandas as pd
  import sys
  import matplotlib.pyplot as plt
  from scipy import ndimage as ndi
  np.set_printoptions(threshold=sys.maxsize)

  txt = pd.read_table('data/2023-12-03-1-aoc.txt', names=['code'])
  arr = np.chararray((txt.size, txt.size), unicode=True)

  txt['code'] = txt.loc[:, 'code'].apply(lambda x: [i for i in x])

  for i, code in enumerate(txt['code']):
      arr[i, :] = code

  print((arr[:15, :15]))
#+end_src

#+RESULTS:
#+begin_example
[['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '5' '3' '.' '4']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '*' '.' '.' '.' '.']
 ['.' '.' '.' '.' '.' '.' '.' '7' '2' '6' '.' '.' '.' '.' '.']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '9' '5']
 ['.' '.' '.' '.' '.' '.' '.' '7' '3' '8' '.' '.' '.' '*' '.']
 ['.' '7' '4' '.' '.' '.' '.' '.' '.' '.' '.' '.' '3' '6' '6']
 ['.' '.' '.' '*' '1' '2' '6' '.' '.' '.' '.' '.' '.' '.' '.']
 ['.' '.' '.' '.' '.' '.' '.' '.' '3' '3' '1' '/' '.' '.' '9']
 ['.' '.' '.' '.' '/' '.' '.' '.' '.' '.' '.' '.' '.' '.' '*']
 ['.' '.' '.' '.' '9' '5' '3' '.' '.' '.' '.' '3' '5' '5' '.']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.' '.']
 ['.' '6' '8' '5' '.' '.' '.' '.' '*' '.' '.' '.' '.' '7' '0']
 ['.' '.' '.' '.' '.' '.' '.' '.' '.' '9' '3' '8' '.' '.' '*']]
#+end_example

Now extract symbols, digits and the empty space. We use the =numpy= character
methods for that. This way, we create a binary mask for all *digits* and a
binary mask for all *empty* space (=.=). The *symbols* are then every character
which is neither.  

#+begin_src jupyter-python
  digits = np.char.isdigit(arr)
  empty = np.char.endswith(arr, '.')
  symbols = ~(digits | empty)
  
  # just for visualization
  plt.figure(figsize=(16, 5))
  plt.subplot(131, title='symbols').matshow(symbols)
  plt.subplot(132, title='digits').matshow(digits)
  plt.subplot(133, title='empty').matshow(empty)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/92e5476ffb971069e91ebd51b0733f8d067ed4f0.png]]

Now we use the image processing technique of dilation on the =symbols= mask. So
that we get a new mask which covers the surroundings of all symbols. We use this
afterwards to check if the digits are near a symbol.

#+begin_src jupyter-python
  struct = ((1, 1, 1), (1, 1, 1), (1, 1, 1))
  dilate = ndi.binary_dilation(symbols, structure=struct)
  plt.figure(figsize=(10, 6))
  plt.subplot(121, title='symbols').matshow(symbols[:15, :15])
  plt.subplot(122, title='symbols dilated').matshow(dilate[:15, :15])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c6e63862aef82ff3f8a64ff3686fb8f7fe239f65.png]]

Creating this masks as before could be understood as a *binary segmentation*, as
each element in our mask is either =True= or =False=. To extract the single
digits, we'll convert the binary digits segmentation into a *instance
segmentation*, where each connected segment has an own index.

#+begin_src jupyter-python
  markers, num_features = ndi.label(digits)
  plt.figure(figsize=(10, 6))
  plt.subplot(121, title='binary segmentation').matshow(
      digits[:15, :15])
  plt.subplot(122, title='instance segmentation').matshow(
      markers[:15, :15], cmap='gnuplot')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/73d9894da10ebf83909ef909e542f608e4d4a097.png]]

Now, for each instance, we check if the dilated binary mask overlaps with the
instance and if yes, we extract the number. 

#+begin_src jupyter-python
  numbers = [int(''.join(arr[markers == i]))
             for i in range(1, num_features+1) 
             if np.any((markers == i) & dilate)]
#+end_src

#+RESULTS:

Then, we just sum up:

#+begin_details
#+begin_summary
Reveal solution!
#+end_summary
#+begin_src jupyter-python
  sum(numbers)
#+end_src

#+RESULTS:
: 527364
#+end_details

*** Part 2

#+begin_quote
The missing part wasn't the only issue - one of the gears in the engine is
wrong. A gear is any * symbol that is adjacent to exactly two part numbers. Its
gear ratio is the result of multiplying those two numbers together. 

This time, you need to find the gear ratio of every gear and add them all up so
that the engineer can figure out which gear needs to be replaced. 

Consider the same engine schematic again:The missing part wasn't the only
issue - one of the gears in the engine is wrong. A gear is any * symbol that is
adjacent to exactly two part numbers. Its gear ratio is the result of
multiplying those two numbers together. 

This time, you need to find the gear ratio of every gear and add them all up so
that the engineer can figure out which gear needs to be replaced. 

Consider the same engine schematic again:
#+end_quote

#+begin_example
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
#+end_example

#+begin_quote
In this schematic, there are *two* gears. The first is in the top left; it has 
part numbers =467= and =35=, so its gear ratio is =16345=. The second gear is in
the lower right; its gear ratio is =451490=. (The =*= adjacent to =617= is not a
gear because it is only adjacent to one part number.) Adding up all of the gear 
ratios produces =467835=. 

*What is the sum of all of the gear ratios in your engine schematic?*
#+end_quote

We'll use the same method as before, but this time only extract =*= and create
the instance segmentation *before* the dilation. Why? Because when we dilate
first, we could merge two independent gears into one instance.

#+begin_src jupyter-python
  gear = np.char.endswith(arr, '*')
  gear_markers, gear_num = ndi.label(gear)

  plt.figure(figsize=(10, 6))
  plt.subplot(131, title='all symbols dilated').matshow(
      symbols[:15, :15])
  plt.subplot(132, title='gears').matshow(
      gear[:15, :15])
  plt.subplot(133, title='gears instances').matshow(
      gear_markers[:15, :15], cmap='gnuplot')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ae256a47b14244f1e8f55b38b4c1f4621e0f2187.png]]

Now, we step through each gear instance, create a mask for that gear, dilate it,
and then step through all digits and check if they are in the gear mask. If we
get two digits in the end, we multiply them to get the dear ratio and save the
ratios to a list.

#+begin_src jupyter-python
  gear_ratios = []
  for i in range(1, gear_num+1):
      gear_binary = gear_markers == i
      gear_dil = ndi.binary_dilation(gear_binary, structure=struct)

      part_numbers = [int(''.join(arr[markers == j]))
                      for j in range(1, num_features+1)
                      if np.any((markers == j) & gear_dil)]
      if len(part_numbers) == 2:
          gear_ratios.append(part_numbers[0] * part_numbers[1])
#+end_src

#+RESULTS:

Now, we just sum the output again:
#+begin_details
#+begin_summary
Reveal solution!
#+end_summary
#+begin_src jupyter-python
  sum(gear_ratios)
#+end_src

#+RESULTS:
: 79026871
#+end_details

** DONE Advent of code 2023 - Tag 3: Getriebeübersetzungen :python:
CLOSED: [2023-12-18 Mo 01:01]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day03.de.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

Dieses Jahr versuche ich mich an den Herausforderungen des *Advent of Code
2023*. Dies ist Tag 3 - siehe [[https:adventofcode.com/2023/day/3]]

Für die Lösungen siehe die englische Version dieses Blogbeitrages.
** DONE Advent of code 2023 - Day 4: Scratchcards :python:
CLOSED: [2023-12-19 Di 00:25]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day04.en.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

This year I try to record my attempt at solving the *Advent of Code 2023*
riddles. This is Day 4 - see [[https:adventofcode.com/2023/day/4]]
*** Part 1
Lets first read the task:

#+begin_quote
The Elf leads you over to the pile of colorful cards. There, you discover dozens
of scratchcards, all with their opaque covering already scratched off. Picking
one up, it looks like each card has two lists of numbers separated by a vertical
bar (=|=): a list of *winning numbers* and then a list of *numbers you have*.
You organize the information into a table (your puzzle input).

As far as the Elf has been able to figure out, you have to figure out which of
the *numbers you have* appear in the list of *winning numbers*. The first match
makes the card worth *one point* and each match after the first *doubles* the
point value of that card.

For example:
#+end_quote

#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

#+begin_quote
In the above example, card 1 has five winning numbers (=41=, =48=, =83=, =86=,
and =17=) and eight numbers you have (=83=, =86=, =6=, =31=, =17=, =9=, =48=,
and =53=). Of the numbers you have, four of them (=48=, =83=, =17=, and =86=)
are winning numbers! That means card 1 is worth =8= points (1 for the first
match, then doubled three times for each of the three matches after the first).

- Card 2 has two winning numbers (=32= and =61=), so it is worth =2= points.
- Card 3 has two winning numbers (=1= and =21=), so it is worth =2= points.
- Card 4 has one winning number (=84=), so it is worth =1= point.
- Card 5 has no winning numbers, so it is worth no points.
- Card 6 has no winning numbers, so it is worth no points.

So, in this example, the Elf's pile of scratchcards is worth =13= points.

Take a seat in the large pile of colorful cards. *How many points are they worth
in total?*
#+end_quote

Loading this data is very similar to *Day 2* - so let's load the data as we did
there. Our goal is to get =win= and =yours= columns holding the respective
digits which we want to compare. We find the numbers with one or more digits
using the regex =\d+=. And we want them to be in *sets* (not lists), as we can
logically compare sets in Python.

#+begin_src jupyter-python
  import pandas as pd
  import re

  txt = pd.read_table('data/2023-12-04-1-aoc.txt', names=['win'])
  txt['id'] = txt.loc[:, 'win'].str.split(':').apply(
      lambda x: int(x[0].strip('Card ')))
  txt['win'] = (txt.loc[:, 'win']
                .str.split(':').apply(lambda x: x[1]))
  txt['yours'] = (txt.loc[:, 'win']
                  .str.split('|')
                  .apply(lambda x: x[1])
                  # get a list of only the numbers / digits
                  .apply(lambda x: re.findall(r'\d+', x))
                  # convert the list of strings to a set of integers
                  .apply(lambda x: set([int(i) for i in x])))
  txt['win'] = (txt.loc[:, 'win']
                .str.split('|')
                .apply(lambda x: x[0])
                .apply(lambda x: re.findall(r'\d+', x))
                .apply(lambda x: set([int(i) for i in x])))

  txt
#+end_src

#+RESULTS:
:RESULTS:
|     | win                                      | id  | yours                                             |
|-----+------------------------------------------+-----+---------------------------------------------------|
| 0   | {32, 36, 7, 9, 10, 12, 82, 85, 95, 31}   | 1   | {2, 7, 9, 10, 12, 14, 21, 22, 23, 24, 31, 32, ... |
| 1   | {35, 76, 16, 82, 19, 22, 88, 59, 60, 95} | 2   | {7, 8, 12, 16, 19, 22, 26, 28, 35, 38, 44, 51,... |
| 2   | {1, 70, 11, 78, 48, 19, 52, 88, 28, 94}  | 3   | {3, 4, 8, 17, 18, 19, 24, 31, 34, 45, 52, 54, ... |
| 3   | {65, 2, 72, 28, 14, 16, 55, 91, 92, 62}  | 4   | {3, 4, 6, 7, 8, 9, 15, 30, 33, 35, 47, 49, 51,... |
| 4   | {38, 41, 75, 77, 50, 24, 94, 60, 61, 30} | 5   | {1, 2, 4, 5, 6, 7, 9, 10, 14, 17, 21, 29, 47, ... |
| ... | ...                                      | ... | ...                                               |
| 213 | {97, 98, 39, 41, 43, 12, 13, 19, 93, 95} | 214 | {5, 10, 17, 20, 28, 29, 33, 34, 36, 50, 51, 52... |
| 214 | {97, 35, 69, 40, 74, 45, 20, 21, 62, 31} | 215 | {1, 8, 15, 17, 18, 25, 30, 33, 42, 44, 47, 52,... |
| 215 | {33, 70, 71, 12, 78, 17, 51, 86, 60, 94} | 216 | {7, 8, 9, 10, 22, 29, 37, 39, 41, 43, 46, 47, ... |
| 216 | {98, 67, 68, 38, 70, 39, 72, 77, 45, 21} | 217 | {8, 21, 22, 25, 26, 31, 37, 41, 42, 48, 54, 57... |
| 217 | {34, 9, 44, 78, 79, 16, 17, 19, 55, 92}  | 218 | {1, 4, 20, 21, 27, 38, 39, 40, 41, 45, 46, 52,... |

218 rows × 3 columns
:END:

Now, we get the [[https://en.wikipedia.org/wiki/Logical_conjunction][logical conjunction]] of =win= and =yours=, these are our winning
numbers. Then, the number of wins is converted to points - for all number of
wins bigger than 1, we can get the points by =2**(n_wins-1)=.

#+begin_src jupyter-python
  txt['n_wins'] = txt.apply(
      lambda row: len(row.loc['win'] & row.loc['yours']), axis=1)
  txt['points'] = txt.loc[:, 'n_wins'].apply(
      lambda x: 2**(x-1) if x > 1 else x)

  txt.loc[:, ['win', 'n_wins', 'points']]
#+end_src

#+RESULTS:
:RESULTS:
|     | win                                      | n_wins | points |
|-----+------------------------------------------+--------+--------|
| 0   | {32, 36, 7, 9, 10, 12, 82, 85, 95, 31}   | 10     | 512    |
| 1   | {35, 76, 16, 82, 19, 22, 88, 59, 60, 95} | 10     | 512    |
| 2   | {1, 70, 11, 78, 48, 19, 52, 88, 28, 94}  | 5      | 16     |
| 3   | {65, 2, 72, 28, 14, 16, 55, 91, 92, 62}  | 0      | 0      |
| 4   | {38, 41, 75, 77, 50, 24, 94, 60, 61, 30} | 0      | 0      |
| ... | ...                                      | ...    | ...    |
| 213 | {97, 98, 39, 41, 43, 12, 13, 19, 93, 95} | 0      | 0      |
| 214 | {97, 35, 69, 40, 74, 45, 20, 21, 62, 31} | 0      | 0      |
| 215 | {33, 70, 71, 12, 78, 17, 51, 86, 60, 94} | 2      | 2      |
| 216 | {98, 67, 68, 38, 70, 39, 72, 77, 45, 21} | 1      | 1      |
| 217 | {34, 9, 44, 78, 79, 16, 17, 19, 55, 92}  | 0      | 0      |

218 rows × 3 columns
:END:

Then, we just sum up:

#+begin_details
#+begin_summary
Reveal solution!
#+end_summary
#+begin_src jupyter-python
  sum(txt.loc[:, 'points'])
#+end_src

#+RESULTS:
: 25004
#+end_details

*** Part 2

#+begin_quote
There's no such thing as "points". Instead, scratchcards only cause you to *win
more scratchcards* equal to the number of winning numbers you have.

Specifically, you win *copies* of the scratchcards below the winning card equal to
the number of matches. So, if card 10 were to have 5 matching numbers, you would
win one copy each of cards 11, 12, 13, 14, and 15.

Copies of scratchcards are scored like normal scratchcards and have the *same
card number* as the card they copied. So, if you win a copy of card 10 and it
has 5 matching numbers, it would then win a copy of the same cards that the
original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until
none of the copies cause you to win any more cards. (Cards will never make you
copy a card past the end of the table.)

This time, the above example goes differently:
#+end_quote

#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

#+begin_quote
- Card 1 has four matching numbers, so you win one copy each of the next four
  cards: cards 2, 3, 4, and 5.
- Your original card 2 has two matching numbers, so you win one copy each of
  cards 3 and 4.
- Your copy of card 2 also wins one copy each of cards 3 and 4.
- Your four instances of card 3 (one original and three copies) have two
  matching numbers, so you win *four* copies each of cards 4 and 5.
- Your eight instances of card 4 (one original and seven copies) have one
  matching number, so you win *eight* copies of card 5.
- Your fourteen instances of card 5 (one original and thirteen copies) have no
  matching numbers and win no more cards.

Once all of the originals and copies have been processed, you end up with =1=
instance of card 1, =2= instances of card 2, =4= instances of card 3, =8=
instances of card 4, =14= instances of card 5, and =1= instance of card 6. In
total, this example pile of scratchcards causes you to ultimately have =30=
scratchcards!

Process all of the original and copied scratchcards until no more scratchcards
are won. Including the original set of scratchcards, *how many total scratchcards
do you end up with?*
#+end_quote

We will use the  =n_wins= column we created before and go from there. We step
through each Game. Each *current game* gets +1 card. Then, we step through the
number of *next games* depending on our =n_wins=. Each of these gets added the
card number of the *current game*.

#+begin_src jupyter-python
  txt['cards'] = 0

  for i, nwin in enumerate(txt.loc[:, 'n_wins']):
      txt.loc[i, 'cards'] += 1
      for j in range(1, nwin+1):
          txt.loc[i+j, 'cards'] += txt.loc[i, 'cards']

  txt.loc[:, ['n_wins', 'cards']]
#+end_src

#+RESULTS:
:RESULTS:
|     | n_wins | cards |
|-----+--------+-------|
| 0   | 10     | 1     |
| 1   | 10     | 2     |
| 2   | 5      | 4     |
| 3   | 0      | 8     |
| 4   | 0      | 8     |
| ... | ...    | ...   |
| 213 | 0      | 9608  |
| 214 | 0      | 8927  |
| 215 | 2      | 8927  |
| 216 | 1      | 12636 |
| 217 | 0      | 21564 |

218 rows × 2 columns
:END:

Now, we just sum the output again:

#+begin_details
#+begin_summary
Reveal solution!
#+end_summary
#+begin_src jupyter-python
  sum(txt['cards'])
#+end_src

#+RESULTS:
: 14427616
#+end_details


** DONE Advent of code 2023 - Tag 4: Rubbelkarten :python:
CLOSED: [2023-12-19 Di 00:25]
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day04.de.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

Dieses Jahr versuche ich mich an den Herausforderungen des *Advent of Code
2023*. Dies ist Tag 4 - siehe [[https:adventofcode.com/2023/day/4]]

Für die Lösungen siehe die englische Version dieses Blogbeitrages.
** TODO Advent of code 2023 - Day 5: If You Give A Seed A Fertilizer :python:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day05.en.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

This year I try to record my attempt at solving the *Advent of Code 2023*
riddles. This is Day 5 - see [[https:adventofcode.com/2023/day/5]]
*** Part 1
Lets first read the task:

#+begin_quote
The almanac (your puzzle input) lists all of the seeds that need to be planted.
It also lists what type of soil to use with each kind of seed, what type of
fertilizer to use with each kind of soil, what type of water to use with each
kind of fertilizer, and so on. Every type of seed, soil, fertilizer and so on is
identified with a number, but numbers are reused by each category - that is,
soil =123= and fertilizer =123= aren't necessarily related to each other.

For example:
#+end_quote

#+begin_example
seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4
#+end_example

#+begin_quote
The almanac starts by listing which seeds need to be planted: seeds =79=, =14=,
=55=, and =13=.

The rest of the almanac contains a list of *maps* which describe how to convert
numbers from a *source category* into numbers in a *destination category*. That
is, the section that starts with =seed-to-soil map=: describes how to convert a
*seed number* (the source) to a *soil number* (the destination). This lets the
gardener and his team know which soil to use with which seeds, which water to
use with which fertilizer, and so on.

Rather than list every source number and its corresponding destination number
one by one, the maps describe entire *ranges* of numbers that can be converted.
Each line within a map contains three numbers: the *destination range start*,
the *source range start*, and the *range length*.

Consider again the example =seed-to-soil map=:

=50 98 2
52 50 48=

The first line has a *destination range start* of =50=, a *source range start*
of =98=, and a *range length* of =2=. This line means that the source range
starts at =98= and contains two values: =98= and =99=. The destination range is
the same length, but it starts at =50=, so its two values are =50= and =51=.
With this information, you know that seed number =98= corresponds to soil number
=50= and that seed number =99= corresponds to soil number =51=.
o
The second line means that the source range starts at =50= and contains =48=
values: =50=, =51=, ..., =96=, =97=. This corresponds to a destination range
starting at =52= and also containing =48= values: =52=, =53=, ..., =98=, =99=.
So, seed number =53= corresponds to soil number =55=.

Any source numbers that *aren't mapped* correspond to the *same* destination
number. So, seed number =10= corresponds to soil number =10=.

So, the entire list of seed numbers and their corresponding soil numbers looks
like this:
#+end_quote

#+begin_example
seed  soil
0     0
1     1
...   ...
48    48
49    49
50    52
51    53
...   ...
96    98
97    99
98    50
99    51
#+end_example

#+begin_quote
With this map, you can look up the soil number required for each initial seed
number:

- Seed number =79= corresponds to soil number =81=.
- Seed number =14= corresponds to soil number =14=.
- Seed number =55= corresponds to soil number =57=.
- Seed number =13= corresponds to soil number =13=.

The gardener and his team want to get started as soon as possible, so they'd
like to know the closest location that needs a seed. Using these maps, find *the
lowest location number that corresponds to any of the initial seeds*. To do
this, you'll need to convert each seed number through other categories until you
can find its corresponding *location number*. In this example, the corresponding
types are:

- Seed =79=, soil =81=, fertilizer =81=, water =81=, light =74=, temperature
  =78=, humidity =78=, location =82=.
- Seed =14=, soil =14=, fertilizer =53=, water =49=, light =42=, temperature
  =42=, humidity =43=, location =43=.
- Seed =55=, soil =57=, fertilizer =57=, water =53=, light =46=, temperature
  =82=, humidity =82=, location =86=.
- Seed =13=, soil =13=, fertilizer =52=, water =41=, light =34=, temperature
  =34=, humidity =35=, location =35=.

So, the lowest location number in this example is =35=.

*What is the lowest location number that corresponds to any of the initial seed
 numbers?*
#+end_quote

Wow, this task is a mouthful...

Let's start slowly and load the data. Our input text document contains several
maps, which are clearly separated and have a title (=seed-to-soil map= etc). So
we can tell pandas where each map starts and give each map a dataframe. I got
the values for the =skiprows= and =nrows= argument by looking at the input file
and... counting
:)

#+begin_src jupyter-python
  import pandas as pd
  import sys

  seeds = pd.read_table('data/2023-12-05-1-aoc.txt', nrows=1, sep=' ',
                        header=None, index_col=0)
  seeds = seeds.values.flatten()

  map_opt = {'filepath_or_buffer': 'data/2023-12-05-1-aoc.txt',
             'header': None, 'sep': ' ', 'dtype': 'Int64'}

  seed_soil = pd.read_table(skiprows=3, nrows=23, **map_opt,
                            names=['dest_start', 'src_start', 'range'])

  soil_fert = pd.read_table(skiprows=28, nrows=9, **map_opt,
                            names=['dest_start', 'src_start', 'range'])

  fert_water = pd.read_table(skiprows=39, nrows=20, **map_opt,
                             names=['dest_start', 'src_start', 'range'])

  water_light = pd.read_table(skiprows=61, nrows=40, **map_opt,
                              names=['dest_start', 'src_start', 'range'])

  light_temp = pd.read_table(skiprows=103, nrows=36, **map_opt,
                             names=['dest_start', 'src_start', 'range'])

  temp_humi = pd.read_table(skiprows=141, nrows=35, **map_opt,
                            names=['dest_start', 'src_start', 'range'])

  humi_loc = pd.read_table(skiprows=178, nrows=26, **map_opt,
                           names=['dest_start', 'src_start', 'range'])

  maps = (seed_soil, soil_fert, fert_water, water_light, light_temp,
          temp_humi, humi_loc)

  print('seeds are just a numpy array:')
  display(seeds)
  print('The "humidity-to-location" map as an example:')
  humi_loc
  #+end_src

#+RESULTS:
:RESULTS:
: seeds are just a numpy array:
: array([3169137700,  271717609, 3522125441,   23376095, 1233948799,
:         811833837,  280549587,  703867355,  166086528,   44766996,
:        2326968141,   69162222, 2698492851,   14603069, 2755327667,
:         348999531, 2600461189,   92332846, 1054656969,  169099767])
: The "humidity-to-location" map as an example:
#+begin_example
    dest_start   src_start      range
0   3490144003  1623866227  218040905
1   1709610578  1620839197    3027030
2    105449249   586389428  113279526
3   1899604338  2167886292  348178199
4   1712637608  2678624215  186966730
5    218728775           0  245776251
6   2472992580   923734334  143670388
7   2616662968  3670169885   15297294
8   2247782537  1395629154  225210043
9            0   480940179  105449249
10  4113852846  3959729057  159909096
11  3322784653  1067404722  167359350
12   923734334  4119638153  175329143
13  1534964496  2516064491  162559724
14  2631960262  3496028440  140849733
15  2862695906  1234764072   97988355
16  1697524220  3636878173   12086358
17  2985646048  1332752427   62876727
18  1099063477  2970241510  435901019
19  4009202281  2865590945  104650565
20  2960684261  2142924505   24961787
21  2772809995  3406142529   89885911
22  4273761942  3648964531   21205354
23  3708184908  1841907132  301017373
24   464505026   245776251  235163928
25  3048522775  3685467179  274261878
#+end_example
:END:

My first attempt was to actually construct ranges like in the example above,
mapping out all possible sources and destinations. Python quickly informed my
that even constructing one =pandas.Series= with =int64= values mapping seeds to
soil would cost 64GB memory - not the best solution.

So we take a different approach. For convenience, let's add a =src_end= and a
=dest_end= column to our maps:


#+begin_src jupyter-python
  for df in maps:
      df['src_end'] = df.loc[:, 'src_start'] + df.loc[:, 'range']
      df['dest_end'] = df.loc[:, 'dest_start'] + df.loc[:, 'range']

  print('Again the "humidity-to-location" map as an example:')
  humi_loc
#+end_src

#+RESULTS:
:RESULTS:
: Again the "humidity-to-location" map as an example:
#+begin_example
    dest_start   src_start      range     src_end    dest_end
0   3490144003  1623866227  218040905  1841907132  3708184908
1   1709610578  1620839197    3027030  1623866227  1712637608
2    105449249   586389428  113279526   699668954   218728775
3   1899604338  2167886292  348178199  2516064491  2247782537
4   1712637608  2678624215  186966730  2865590945  1899604338
5    218728775           0  245776251   245776251   464505026
6   2472992580   923734334  143670388  1067404722  2616662968
7   2616662968  3670169885   15297294  3685467179  2631960262
8   2247782537  1395629154  225210043  1620839197  2472992580
9            0   480940179  105449249   586389428   105449249
10  4113852846  3959729057  159909096  4119638153  4273761942
11  3322784653  1067404722  167359350  1234764072  3490144003
12   923734334  4119638153  175329143  4294967296  1099063477
13  1534964496  2516064491  162559724  2678624215  1697524220
14  2631960262  3496028440  140849733  3636878173  2772809995
15  2862695906  1234764072   97988355  1332752427  2960684261
16  1697524220  3636878173   12086358  3648964531  1709610578
17  2985646048  1332752427   62876727  1395629154  3048522775
18  1099063477  2970241510  435901019  3406142529  1534964496
19  4009202281  2865590945  104650565  2970241510  4113852846
20  2960684261  2142924505   24961787  2167886292  2985646048
21  2772809995  3406142529   89885911  3496028440  2862695906
22  4273761942  3648964531   21205354  3670169885  4294967296
23  3708184908  1841907132  301017373  2142924505  4009202281
24   464505026   245776251  235163928   480940179   699668954
25  3048522775  3685467179  274261878  3959729057  3322784653
#+end_example
:END:

Now, we actually compute the mapping. For each seed, we go through all mappings,
and in each mapping through each row. We find the row which contains the mapping
and exctract the destination, which is the source for the next map until we
reach the last map which gives us the locations.

- Approach 1: =df.itertuples()= is a convenient way to step through a
  =pandas.DataFrame= in this example. It is faster than =df.iterrows()= and
  returns the row as a =NamedTuple= -  nice!

- Approach 2: I actually wondered if it would be faster to get all maps in one
  =pd.DataFrame= and then iterate through the mappings. For that, let's
  construct a new DataFrame =maps_df=, which contains all =maps=. Since the maps
  have different lengths it is important to cast the datatype to =Int64=, which
  is short for =pd.Int64Dtype()= and keeps values as integers, even if =NA=
  values are in the same column.

- Approach 3: A third alternative I tested (not shown here) was to check if a
  value is in a Python =range= with the =in= operator as in: =if 3 in
  range(5):...= . This was way too slow.

#+begin_src jupyter-python
  # mapping version 1
  def get_location(seed):
      current = seed
      for df in maps:
          current_map = [row
                         for row in df.itertuples()
                         if ((current > row.src_start)
                             and (current < row.src_end))]
          if len(current_map) == 0:
              pass
          elif len(current_map) == 1:
              current = (current_map[0].dest_start
                         + (current - current_map[0].src_start))
          else:
              raise ValueError('This should not happen!')
      return current

  # mapping version 2 - around 10 times slower
  # you need to rename the maps_df columns so that they have a unique id
  # e.g. 'src_start_1', 'src_start_2' etc

  # maps_df = pd.concat(maps, axis='columns')

  # def get_dest(i, src):
  #     return (maps_df[(src > maps_df.loc[:, f'src_start_{i}']) &
  #                     (src < maps_df.loc[:, f'src_end_{i}'])]
  #             .loc[:, f'dest_start_{i}']
  #             .iloc[0])

  # def get_location2(seed):
  #     dest = seed
  #     i = 1
  #     while i < 7:
  #         dest = get_dest(i, dest)
  #         i += 1
  #     return dest

  %timeit get_location(seeds[0])
#+end_src

#+RESULTS:
: 7.81 ms ± 300 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

Now let's get a list of locations:

#+begin_src jupyter-python
  locations = [get_location(s) for s in seeds]
  locations
#+end_src

#+RESULTS:
| 2493982655 | 3209845376 | 3992357533 | 4163131463 | 4104485616 | 1952252479 | 3218677354 | 388071289 | 2181441450 | 2594336315 | 4049507670 | 2084517144 | 3119633635 | 428978312 | 3518771991 | 3704555655 | 953918455 | 2107687768 | 3448046330 | 2184454689 |

Lastly, just get the minimum of all location values.

#+begin_details
#+begin_summary
Reveal solution!
#+end_summary
#+begin_src jupyter-python
  min(locations)
#+end_src

#+RESULTS:
: 388071289
#+end_details

*** Part 2

#+begin_quote
Everyone will starve if you only plant such a small number of seeds. Re-reading
the almanac, it looks like the =seeds:= line actually describes *ranges of seed
numbers*.

The values on the initial =seeds:= line come in pairs. Within each pair, the
first value is the *start* of the range and the second value is the *length* of
the range. So, in the first line of the example above:

=seeds: 79 14 55 13=

This line describes two ranges of seed numbers to be planted in the garden. The
first range starts with seed number =79= and contains =14= values: =79=, =80=,
..., =91=, =92=. The second range starts with seed number =55= and contains =13=
values: =55=, =56=, ..., =66=, =67=.

Now, rather than considering four seed numbers, you need to consider a total of
=27= seed numbers.

In the above example, the lowest location number can be obtained from seed
number =82=, which corresponds to soil =84=, fertilizer =84=, water =84=, light
=77=, temperature =45=, humidity =46=, and location =46=. So, the lowest
location number is =46=.

Consider all of the initial seed numbers listed in the ranges on the first line
of the almanac. *What is the lowest location number that corresponds to any of
the initial seed numbers?*
#+end_quote

Let's first construct a dataframe containing the range of seeds:

#+begin_src jupyter-python
  seeds_df = pd.DataFrame({'start': seeds[::2],
                           'range': seeds[1::2],
                           'end': seeds[::2] + seeds[1::2]})
  print(f'There are {sum(seeds_df.loc[:, "range"]):_} seeds in total')
  seeds_df

#+end_src

#+RESULTS:
:RESULTS:
: There are 2_549_759_327 seeds in total
|   | start      | range     | end        |
|---+------------+-----------+------------|
| 0 | 3169137700 | 271717609 | 3440855309 |
| 1 | 3522125441 | 23376095  | 3545501536 |
| 2 | 1233948799 | 811833837 | 2045782636 |
| 3 | 280549587  | 703867355 | 984416942  |
| 4 | 166086528  | 44766996  | 210853524  |
| 5 | 2326968141 | 69162222  | 2396130363 |
| 6 | 2698492851 | 14603069  | 2713095920 |
| 7 | 2755327667 | 348999531 | 3104327198 |
| 8 | 2600461189 | 92332846  | 2692794035 |
| 9 | 1054656969 | 169099767 | 1223756736 |
:END:

Now - I really needed some time to finally realize, that going through all seed
values is really unfeasable. So how do we deal with this problem?

In the end, we need the lowest location number - thus our approach is to take
the =humi_loc= map (where ~dest_start \== 0~), start with the lowest location
number and go up and get the corresponding seed values. The location of the
first seed value which is inside =seeds_df= is our solution.

So first we rebuild the =get_location= function to a =get_seed= function (we
reverse the =maps= tuple with =maps[::-1]= and switch =src= and =dest=).

#+begin_src jupyter-python :results scalar
  def get_seed(location):
      current = location
      for df in maps[::-1]:
          current_map = [row
                         for row in df.itertuples()
                         if ((current >= row.dest_start)
                             and (current < row.dest_end))]
          if len(current_map) == 0:
              pass
          elif len(current_map) == 1:
              current = (current_map[0].src_start
                         + (current - current_map[0].dest_start))
          else:
              raise ValueError('This should not happen!')
      return current
#+end_src

#+RESULTS:

To go through the possible locations efficiently, I decided to use a Python
*generator function* to go through the locations - this function does not store
the full list of =105_449_249= possible locations in the first batch
(=humi_loc.loc[9, 'dest_start']=) in memory - nice for our big numbers.

Lastly, we deal with the sheer amount of possible values by performing a *grid
search*. First, we check every millionth location. After the first match, we
stop this search and check the last million locations before the match with a
finer grid and so on. The last grid is just =1=, so we find our lowest location.

#+begin_src jupyter-python
  def get_generator(start, end, step=1):
      next = start
      while next < end:
          yield next
          next += step

  def grid_search(start: int, end: int, grid: list[int]):
      for g in grid:
          print(f'Start search with grid={g}')
          loc_gen = get_generator(start, end, g)
          for l in loc_gen:
              current = get_seed(l)
              if any((current >= seeds_df.loc[:, 'start']) & (current < seeds_df.loc[:, 'end'])):
                  print(f'location {l} is the lowest which contains one of the given seeds ({current})')
                  start = l - g
                  end = l
                  break
      print('Finished search')

  grid_search(start=humi_loc.loc[9, 'dest_start'],
              end=humi_loc.loc[9, 'dest_end'],
              grid=[1_000_000, 100_000, 1000, 1])
#+end_src

#+RESULTS:
: Start search with grid=1000000
: location 85000000 is the lowest which contains one of the given seeds (2605777210)
: Start search with grid=100000
: location 84300000 is the lowest which contains one of the given seeds (2605077210)
: Start search with grid=1000
: location 84207000 is the lowest which contains one of the given seeds (2604984210)
: Start search with grid=1
: location 84206669 is the lowest which contains one of the given seeds (2604983879)
: Finished search

** TODO Advent of code 2023 - Tag 5: Wenn du einem Samen Dünger gibst :python:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc2023-day05.de.md
:header-args:jupyter-python: :session /jpy:localhost#8888:b37e524a-8134-4d8f-b24a-367acaf1bdd3 :pandoc t :kernel python3 :exports both
:END:

Dieses Jahr versuche ich mich an den Herausforderungen des *Advent of Code
2023*. Dies ist Tag 5 - siehe [[https:adventofcode.com/2023/day/5]]

Für die Lösungen siehe die englische Version dieses Blogbeitrages.
** TODO Connection on Mount Misery vs Corona
:PROPERTIES:
:EXPORT_FILE_NAME: mount-misery-corona.en.md
:END:

Eine Grundüberlegung bei Noah Sham's Mount Misery: It is not self that heals,
but connection.

Corona: Connection (soziale Nähe) tötet.

** TODO Verbindung in Mount Misery vs Corona

:PROPERTIES:
:EXPORT_FILE_NAME: mount-misery-corona.de.md
:END:

Siehe Englische Version.

** TODO Thoughts on Thea Dorn about consolation in pandemic times

:PROPERTIES:
:EXPORT_FILE_NAME: thea-dorn-trost.en.md
:END:

See German version.

** TODO Gedanken zu Thea Dorn über Trost und Religiösität in Zeiten der Pandemie

:PROPERTIES:
:EXPORT_FILE_NAME: thea-dorn-trost.de.md
:END:

In einer kürzlich erschienenen Folge des ZEIT-Podcasts "Alles gesagt" besprechen
Thea Dorn, Jochen Wegner, und Christian Amend das Buch /Trost. Briefe an Max./.
Sie nähern sich einem Kernproblem des modernen Menschen: wir seien darauf aus,
entweder vor einem unerwünschten Ereignis Risiken zu minimieren, oder nachher
Schadenersatz und Verantwortung zu fordern. Wir hätten verlernt, mit den
Unwägbarkeiten des Lebens umzugehen. Religiösität mit ihrer trostspendenen
Wirkung sei der entscheidende Ausweg.

Punkte, die ich ansprechen möchte:
- Thea Dorn zitiert NIetzsche platt als "Gott ist tot, der Mensch ist Gott, etc"
  → eingehen auf Nietzsche's "Gott ist tot" als Aufruf an Mensch in der
  "aufgeklärten" Welt, dass es eine neue Begründung für basale Dinge wie
  Menschenrechte, oder auch Trost, braucht. Glauben als mentaler Trick. "Gott
  ist tot" als Aufruf und mit Hoffnung besetzt, eine nachhaltigere, tiefere
  Basis zu finden.
- Sie geht zurück zur Religiösität. Ich als ostdeutsch sozialisiert kann nicht
  zurückgehen.
  Ich wurde als Kind nicht an Glauben herangeführt, es bleibt für mich ein
  unzugängliches Thema, welches nicht als ehrlich und wahren Trost annehmen
  kann. Ich weiß unverrückbar, dass das Leben ein kurzer, zufälliger Moment ist,
  dass nach dem Tod nichts ist, dass das Leben am Ende keinen höheren Sinn hat.
  Dies ist mein Ausgangspunkt. Ist dies der Grund, warum ich bei diesen
  Überlegungen keine Hoffnungslosigkeit spüre? Ich muss nicht dabei verweilen,
  ich kann einen Schritt weitergehen: letztendlich zählt das, was ich in meinem
  jetzigen Leben tue.
- Dass es Leben gibt, ist chemischer Zufall, dass es menschliches Leben gibt,
  ist evolutionärer Zufall, dass ich in einem reichen Land geboren werde, ist
  geschichtlicher Zufall, dass meine Eltern mich gut versorgen und großziehen
  können, ist familiärer Zufall. Brauchen wir eine Zufallsethik? Wenn so viele
  Teile unserer Existenz Zufall sind, ist das genug, um Trost zu spenden?
- Trifft das Unheil ein, ist dies ein Schicksalsschlag, aber nicht auch eine
  statistische Größe? Das Medizinstudium zeigt mir: die ganze Zeit erkranken
  Menschen, während ich oft glimpflich davonkomme. Ich bin nicht mit 18J in
  einen tödlichen Verkehrsunfall verwickelt worden. Ich bin nicht mit 23J an
  akuter Leukämie gestorben. Sehe ich diese statistischen Bedrohungen die ganze
  Zeit als reale Bedrohungen, werde ich gewiss verrückt, verzweifeln,
  hoffnungslos.
- Ich bin es jedoch nicht. Warum nicht? Gewiss aufgrund einer gewissen stoischen
  Haltung. Das reicht aber nicht, es braucht auch einen aktiven Part -
  Risikominimierung bietet letztlich dieses Gewissen: "ich habe mein möglichstes
  getan". Christian Drosten hatte eine ähnliche Losung: wir müssen besorgt sein
  und Maßnahmen treffen - aber nicht panisch.

Weiteres Thema: Thea Dorn sagt, Naturwissenschaftler*innen wägen gegeneinander
ab: wir rechnen aus, was wieviel Leid bringt, dann nehmen wir das, was weniger
bringt. Das sei Utilitarismus.  Sie jedoch sagt: wir müssen abwägen von Leben
retten vs "Freiheit".

- mit Friederike Schmitz: Abwägen im juristischen Sinne IST Utilitarismus!
** TODO Reading "The Shadow of the Sun" by Ryszard Kapuściński       :@books:
:PROPERTIES:
:EXPORT_FILE_NAME: shadow-of-sun
:END:
- State "TODO"       from "PENDING"    [2021-01-13 Mi 23:24]
- State "PENDING"    from "DONE"       [2021-01-13 Mi 23:24]
General impression: thoughtful book, mostly he tries to avoid [[https://www.youtube.com/watch?v=D9Ihs241zeg][single stories]] and
gives an impression of different scenes in or between different African
countries from the end of the 1950s till the 1990s. From time to time he tries
to explain certain view or mentalities in African countries, which might come of
as condescending from todays view and be of more interest to non-African readers
than to African readers.

#+hugo: more

In this blog post I will share the more impressionist quotes I liked, while some
historical takeaways will be collected in [[#africa][Notes]]
**** p 29: Course and temperature of the /first greeting/ defines fate of the relationship
- from very first second: exhibit enormous primal joy and geniality
- extend hand in large, vigorous gesture
- loud /laughter/, many questions
**** p 36ff.: colonial heritage
- a state wherein the civil servant received renumeration beyond all measure
  and reason (white low burocratic suddenly gets villa, servants, ...)
  + after independence this system gives fast rise to new elites
  + french: /la politique du ventre/ (... of the stomach)
- 10.000 kingodms, federations and stateless, but independent tribal
  associations crammed in ~40 colonies! (without asking)
- ports - only leeches on the body of Africa, points of export for slaves,
  gold and ivory
- p52: *Why Indians built the railway*
  + White worker from Europe \to was master, could not do physical labour
  + African worker \to "did not exist", the concept of wages was missing and
    British had system of forced labour later
- p82: *Islands around Africa*
  + Were bases for sailors, merchants, and robbers (especially Europeans)
  + For unstable African boats hard to reach \to spot for concentration camps
    for slave trade
- p83: The philosophy that inspired the construction of [[https://en.wikipedia.org/wiki/Kolyma_Tales][Kolyma]] and [[https://en.wikipedia.org/wiki/Auschwitz_concentration_camp][Auschwitz]],
  one of obsessive content and hatred, vileness and brutality, was formulated
  and set down centuries earlier by the captains of the /Martha/ and the /Progress/,
  the [[https://en.wikipedia.org/wiki/Mary_Ann_(1772_ship)][Marie Ann]] and the /Rainbow/
**** p60: Secrets of Serengeti
- lions attacking humans \to are old outcasts
- where are the elephant cemetries \to on bottom of lakes
**** Europeans, Africans and Racism
- p70: Poland vs Tansania
  + children asking Ryszard in Poland "And did you see many cannibals?"
  + Mothers in Tanganyika to their children: "You had better be good, or else
    the /mzungu/ (Swahili: the white man, the European) will eat you!"
- p110: So often I had felt irritated with people who arrived here, lived in
  "little Europe" or "little America" (e.g. in luxury hotels), and departed,
  bragging later that they had been to Africa, a place that in reality they had
  never seen.
**** wonders
- Lalibela: 11 great churches carved in stone and misery
