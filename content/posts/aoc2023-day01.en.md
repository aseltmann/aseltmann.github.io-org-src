+++
title = "Advent of code 2023 - Day 1: Trebuchet?!"
author = ["Alex Seltmann"]
date = 2023-12-10T03:05:00+01:00
lastmod = 2023-12-11T23:42:09+01:00
tags = ["python"]
draft = false
creator = "Emacs 29.1 (Org mode 9.7 + ox-hugo)"
+++

This year I try to record my attempt at solving the **Advent of Code 2023**
riddles. This is Day 1 - see <https:adventofcode.com/2023/day/1>


## Part 1 {#part-1}

Our first task is the following:

> The newly-improved calibration document consists of lines of text; each line
> originally contained a specific calibration value that the Elves now need to
> recover. On each line, the calibration value can be found by combining the first
> digit and the last digit (in that order) to form a single two-digit number.
>
> For example:

```text
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
```

> In this example, the calibration values of these four lines are 12, 38, 15,
> and 77. Adding these together produces 142.
>
> Consider your entire calibration document. What is the sum of all of the
> calibration values?

Lets start jupyter in our shell to start coding!

```sh
  conda activate tf
  jupyter lab --no-browser --port=8888
```

First, load the test document

```python
  import pandas as pd
  import re

  txt = pd.read_table('data/2023-12-01-1-aoc.txt', names=['code'])
  txt
```

```text
---------------------------------------------------------------------------
FileNotFoundError                         Traceback (most recent call last)
/tmp/ipykernel_33969/1324215899.py in <module>
      2 import re
      3
----> 4 txt = pd.read_table('data/2023-12-01-1-aoc.txt', names=['code'])
      5 txt

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    309                     stacklevel=stacklevel,
    310                 )
--> 311             return func(*args, **kwargs)
    312
    313         return wrapper

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/readers.py in read_table(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, on_bad_lines, encoding_errors, delim_whitespace, low_memory, memory_map, float_precision)
    681     kwds.update(kwds_defaults)
    682
--> 683     return _read(filepath_or_buffer, kwds)
    684
    685

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/readers.py in _read(filepath_or_buffer, kwds)
    480
    481     # Create the parser.
--> 482     parser = TextFileReader(filepath_or_buffer, **kwds)
    483
    484     if chunksize or iterator:

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/readers.py in __init__(self, f, engine, **kwds)
    809             self.options["has_index_names"] = kwds["has_index_names"]
    810
--> 811         self._engine = self._make_engine(self.engine)
    812
    813     def close(self):

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/readers.py in _make_engine(self, engine)
   1038             )
   1039         # error: Too many arguments for "ParserBase"
-> 1040         return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
   1041
   1042     def _failover_to_python(self):

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py in __init__(self, src, **kwds)
     49
     50         # open handles
---> 51         self._open_handles(src, kwds)
     52         assert self.handles is not None
     53

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/parsers/base_parser.py in _open_handles(self, src, kwds)
    220         Let the readers open IOHandles after they are done with their potential raises.
    221         """
--> 222         self.handles = get_handle(
    223             src,
    224             "r",

~/Programme/miniconda3/envs/tf/lib/python3.9/site-packages/pandas/io/common.py in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)
    700         if ioargs.encoding and "b" not in ioargs.mode:
    701             # Encoding
--> 702             handle = open(
    703                 handle,
    704                 ioargs.mode,

FileNotFoundError: [Errno 2] No such file or directory: 'data/2023-12-01-1-aoc.txt'
```

Second, extract the digits. I had to wrap my head around regex matching in
python first, because I first tried `pandas.extract` (which only extracts the
first match), then `pandas.extractall` (which extracts all matches but puts them
into a multiindex which makes things more difficult in this case). So I settled
for the `re.findall` version, which returns a list. To concatenate the elements
in the list, we take use the `join` function.

```python
  txt['digits'] = txt.loc[:, 'code'].apply(
      lambda x: ''.join(re.findall(r'(\d+)', x)))
  txt
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/1268720339.py in <module>
----> 1 txt['digits'] = txt.loc[:, 'code'].apply(
      2     lambda x: ''.join(re.findall(r'(\d+)', x)))
      3 txt

NameError: name 'txt' is not defined
```

Next, combine the first and the last digit and convert the result from string to integer

```python
  txt['calibration'] = txt.loc[:, 'digits'].apply(
      lambda x: int(x[0] + x[-1]))
  txt
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/3867935527.py in <module>
----> 1 txt['calibration'] = txt.loc[:, 'digits'].apply(
      2     lambda x: int(x[0] + x[-1]))
      3 txt

NameError: name 'txt' is not defined
```

Lastly, get the sum of our calibration numbers

```python
  txt.loc[:, 'calibration'].sum()
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/2632495052.py in <module>
----> 1 txt.loc[:, 'calibration'].sum()

NameError: name 'txt' is not defined
```


## Part 2 {#part-2}

Now follows part two:

> Your calculation isn't quite right. It looks like some of the digits are
> actually spelled out with letters: one, two, three, four, five, six, seven,
> eight, and nine also count as valid "digits".
>
> Equipped with this new information, you now need to find the real first and last
> digit on each line. For example:

```text
two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
```

> In this example, the calibration values are 29, 83, 13, 24, 42, 14, and 76.
> Adding these together produces 281.
>
> What is the sum of all of the calibration values?

Okay, let's see if we can update the pattern matching. To deal with potential
overlapping values like `oneight` which contains `one` as well as `eight`, I
used the regex positive lookahead `?=` as described [here](https://stackoverflow.com/a/5616910). Because this enables
capturing overlapping values, I used `\d` (one digit) instead of `\d+` (one or
more digits), otherwise digits might double. Afterwards, just replace the
spelled out digits with their numerical value.

```python
  for i, r in enumerate(txt.loc[:, 'code']):
      matches = re.findall(
          r'(?=(\d|one|two|three|four|five|six|seven|eight|nine))', r)
      result = ''.join([match for match in matches])
      result = result.replace('one', '1').replace('two', '2').replace(
          'three', '3').replace('four', '4').replace('five', '5').replace(
          'six', '6').replace('seven', '7').replace('eight', '8').replace(
          'nine', '9')
      txt.loc[i, 'digits2'] = result
  txt
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/313059938.py in <module>
----> 1 for i, r in enumerate(txt.loc[:, 'code']):
      2     matches = re.findall(
      3         r'(?=(\d|one|two|three|four|five|six|seven|eight|nine))', r)
      4     result = ''.join([match for match in matches])
      5     result = result.replace('one', '1').replace('two', '2').replace(

NameError: name 'txt' is not defined
```

Now, construct the calibration value as before...

```python
  txt['calibration2'] = txt.loc[:, 'digits2'].apply(lambda x: int(x[0] + x[-1]))
  txt
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/3025969514.py in <module>
----> 1 txt['calibration2'] = txt.loc[:, 'digits2'].apply(lambda x: int(x[0] + x[-1]))
      2 txt

NameError: name 'txt' is not defined
```

... and get the correct sum!

```python
  txt.loc[:, 'calibration2'].sum()
```

```text
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_33969/429421036.py in <module>
----> 1 txt.loc[:, 'calibration2'].sum()

NameError: name 'txt' is not defined
```
